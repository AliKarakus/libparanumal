/*

The MIT License (MIT)

Copyright (c) 2017 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

#define cubeThreads				\
    for(int k=0;k<p_cubNq;++k;@inner(2))	\
      for(int j=0;j<p_cubNq;++j;@inner(1))	\
	for(int i=0;i<p_cubNq;++i;@inner(0))


@kernel void insSubcycleAdvectionCubatureVolumeHex3D_orig(const dlong Nelements,
						     @restrict const  dfloat *  vgeo,
						     @restrict const  dfloat *  cubvgeo,
						     @restrict const  dfloat *  cubDT,
						     @restrict const  dfloat *  cubPDT,
						     @restrict const  dfloat *  cubInterp,
						     @restrict const  dfloat *  cubProject,
						     @restrict const  dfloat *  cUe,
						     @restrict const  dfloat *  U,
						     @restrict  dfloat *  RHS){
  
  //----------------------------@kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_cubDT[p_cubNq][p_cubNq];
    @shared dfloat s_cubInterp[p_Nq][p_cubNq];
    @shared dfloat s_cubProject[p_cubNq][p_Nq];

    @shared dfloat s_tmp[p_cubNq][p_cubNq][p_cubNq];

    @shared dfloat s_Ud[p_cubNq][p_cubNq][p_cubNq];
    @shared dfloat s_Vd[p_cubNq][p_cubNq][p_cubNq];
    @shared dfloat s_Wd[p_cubNq][p_cubNq][p_cubNq];

    @exclusive dfloat r_IUd, r_IVd, r_IWd;
    
    cubeThreads{
      const int id = i+j*p_cubNq + k*p_cubNq*p_cubNq;
      if (id<p_Nq*p_cubNq) {
	s_cubInterp[0][id] = cubInterp[id];
	s_cubProject[0][id] = cubProject[id];
      }

      if(k==0)
	s_cubDT[j][i] = cubDT[i + j*p_cubNq];

      if(k<p_Nq && j<p_Nq && i<p_Nq){
	const dlong id = e*p_Np*p_NVfields + k*p_Nq*p_Nq + j*p_Nq + i;
	s_Ud[k][j][i] = U[id+0*p_Np];
	s_Vd[k][j][i] = U[id+1*p_Np];
	s_Wd[k][j][i] = U[id+2*p_Np];
      }
    }

    @barrier("local");
    
    cubeThreads{
      if(i<p_Nq && j<p_Nq){
	r_IUd = 0; r_IVd = 0; r_IWd = 0;

#pragma unroll p_Nq
	for(int n=0;n<p_Nq;++n){
	  dfloat Ikn = s_cubInterp[n][k];
		
	  r_IUd += Ikn*s_Ud[n][j][i];
	  r_IVd += Ikn*s_Vd[n][j][i];
	  r_IWd += Ikn*s_Wd[n][j][i];
	}
      }
    }

    @barrier("local");
    
    cubeThreads{
      if(i<p_Nq && j<p_Nq){
	s_Ud[k][j][i] = r_IUd;
	s_Vd[k][j][i] = r_IVd;
	s_Wd[k][j][i] = r_IWd;
      }
    }

    @barrier("local");

    cubeThreads{
      if(i<p_Nq){
	r_IUd = 0; r_IVd = 0; r_IWd = 0;

#pragma unroll p_Nq
	for(int n=0;n<p_Nq;++n){
	  dfloat Ijn = s_cubInterp[n][j];

	  r_IUd += Ijn*s_Ud[k][n][i];
	  r_IVd += Ijn*s_Vd[k][n][i];
	  r_IWd += Ijn*s_Wd[k][n][i];
	}
      }
    }

    @barrier("local");
    
    cubeThreads{
      if(i<p_Nq){
	s_Ud[k][j][i] = r_IUd;
	s_Vd[k][j][i] = r_IVd;
	s_Wd[k][j][i] = r_IWd;
      }
    }

    @barrier("local");
    
    cubeThreads{

      r_IUd = 0; r_IVd = 0; r_IWd = 0;
      
#pragma unroll p_Nq
      for(int n=0;n<p_Nq;++n){
	dfloat Iin = s_cubInterp[n][i];
	
	r_IUd += Iin*s_Ud[k][j][n];
	r_IVd += Iin*s_Vd[k][j][n];
	r_IWd += Iin*s_Wd[k][j][n];
      }
    }

    @barrier("local");

    cubeThreads{

      const dlong id = e*p_cubNp*p_NVfields + k*p_cubNq*p_cubNq + j*p_cubNq + i;
      dfloat cUn = cUe[id+0*p_cubNp];
      s_tmp[k][j][i] = cUn;

      s_Ud[k][j][i] = r_IUd;
      s_Vd[k][j][i] = r_IVd;
      s_Wd[k][j][i] = r_IWd;
    }
    
    @exclusive dfloat divU, divV, divW;
    
    @barrier("local");
    
    cubeThreads{
      divU = 0; divV = 0; divW = 0;

#pragma unroll p_cubNq
      for (int n=0;n<p_cubNq;n++) {
	
	const dfloat Utmp = s_tmp[k][j][n];
	const dfloat Dr = s_cubDT[n][i]*Utmp;
	
	divU += Dr*s_Ud[k][j][n];
	divV += Dr*s_Vd[k][j][n];
	divW += Dr*s_Wd[k][j][n];
      }
    }

    @barrier("local");
    
    cubeThreads{
      const dlong id = e*p_cubNp*p_NVfields + k*p_cubNq*p_cubNq + j*p_cubNq + i;
      dfloat cVn = cUe[id+1*p_cubNp];
      s_tmp[k][j][i] = cVn;
    }

    @barrier("local");

    cubeThreads{
#pragma unroll p_cubNq
      for (int n=0;n<p_cubNq;n++) {

	dfloat Vtmp = s_tmp[k][n][i];
	const dfloat Ds = s_cubDT[n][j]*Vtmp;
	
	divU += Ds*s_Ud[k][n][i];
	divV += Ds*s_Vd[k][n][i];
	divW += Ds*s_Wd[k][n][i];
      }
    }

    cubeThreads{
      const dlong id = e*p_cubNp*p_NVfields + k*p_cubNq*p_cubNq + j*p_cubNq + i;
      dfloat cWn = cUe[id+2*p_cubNp];
      s_tmp[k][j][i] = cWn;
    }

    @barrier("local");
    
    cubeThreads{
      
#pragma unroll p_cubNq
      for (int n=0;n<p_cubNq;n++) {
	
	dfloat Wtmp = s_tmp[n][j][i];
	const dfloat Dt = s_cubDT[n][k]*Wtmp;
	
	divU += Dt*s_Ud[n][j][i];
	divV += Dt*s_Vd[n][j][i];
	divW += Dt*s_Wd[n][j][i];
      }
    }

    @barrier("local");
    
    cubeThreads{
      s_Ud[k][j][i] = divU;
      s_Vd[k][j][i] = divV;
      s_Wd[k][j][i] = divW;
    }

    @barrier("local");

    cubeThreads{
      divU = 0; divV = 0; divW = 0;

      if(k<p_Nq){
#pragma unroll p_cubNq
	for(int n=0;n<p_cubNq;++n){
	  dfloat Pkn = s_cubProject[n][k];
	  divU += Pkn*s_Ud[n][j][i];
	  divV += Pkn*s_Vd[n][j][i];
	  divW += Pkn*s_Wd[n][j][i];
	}
      }
    }

    @barrier("local");

    cubeThreads{
    
      s_Ud[k][j][i] = divU;
      s_Vd[k][j][i] = divV;
      s_Wd[k][j][i] = divW;
    }
    
    @barrier("local");
    
    cubeThreads{
      divU = 0; divV = 0; divW = 0;

      if(j<p_Nq && k<p_Nq){
#pragma unroll p_cubNq
	for(int n=0;n<p_cubNq;++n){
	  dfloat Pjn = s_cubProject[n][j];
	  divU += Pjn*s_Ud[k][n][i];
	  divV += Pjn*s_Vd[k][n][i];
	  divW += Pjn*s_Wd[k][n][i];
	}
      }
    }


    @barrier("local");
    
    cubeThreads{
      s_Ud[k][j][i] = divU;
      s_Vd[k][j][i] = divV;
      s_Wd[k][j][i] = divW;
    }

    @barrier("local");
    
    cubeThreads{
      divU = 0; divV = 0; divW = 0;

      if(i<p_Nq & j<p_Nq && k<p_Nq){
#pragma unroll p_cubNq
	for(int n=0;n<p_cubNq;++n){
	  dfloat Pin = s_cubProject[n][i];
	  divU += Pin*s_Ud[k][j][n];
	  divV += Pin*s_Vd[k][j][n];
	  divW += Pin*s_Wd[k][j][n];
	}

	const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
	const dfloat invJW = vgeo[gid + p_IJWID*p_Np];
	
	const dlong id = e*p_Np*p_NVfields + k*p_Nq*p_Nq + j*p_Nq + i;
	RHS[id+0*p_Np] = invJW*divU;
	RHS[id+1*p_Np] = invJW*divV;
	RHS[id+2*p_Np] = invJW*divW;
      }
    }
  }
}

#define sliceThreads				\
    for(int b=0;b<p_cubNq;++b;@inner(1))	\
      for(int a=0;a<p_cubNq;++a;@inner(0))




// TW: seems to be most efficient atm
// 2d threads, all fields, no geo, 2d slices of LDS + 1 cube of LDS v03
@kernel void insSubcycleAdvectionCubatureVolumeHex3D(const dlong Nelements,
						     @restrict const  dfloat *  vgeo,
						     @restrict const  dfloat *  cubvgeo,
						     @restrict const  dfloat *  cubDT,
						     @restrict const  dfloat *  cubPDT,
						     @restrict const  dfloat *  cubInterp,
						     @restrict const  dfloat *  cubProject,
						     @restrict const  dfloat *  cUe,
						     @restrict const  dfloat *  U,
						     @restrict  dfloat *  RHS){
  
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {
    
    @shared dfloat s_cubDT[p_cubNq][p_cubNq];

#ifdef FLATTEN
    @shared dfloat s_cubInterpFlat[p_Nq*p_cubNq];
    @shared dfloat s_cubProjectFlat[p_Nq*p_cubNq];
#else
    @shared dfloat s_cubInterp[p_Nq][p_cubNq];
    @shared dfloat s_cubProject[p_cubNq][p_Nq];
#endif
    @shared dfloat s_tmpU[p_dim][p_cubNq][p_cubNq][p_cubNq];
    
    sliceThreads{
      int i = a, j = b;

#if 0
      int n = i + j*p_cubNq;
      if (j<p_Nq){
	s_cubInterpFlat[n] = cubInterp[n];
      }
      int nT = j + i*p_Nq;
      if (j<p_Nq){
	s_cubProjectFlat[nT] = cubProject[n];
      }

      s_cubDT[i][j] = cubDT[n]; // note transform
#else
      const int id = i+j*p_cubNq;
      if (id<p_Nq*p_cubNq) {
	s_cubInterp[0][id] = cubInterp[id];
	s_cubProject[0][id] = cubProject[id];
      }
      
      s_cubDT[j][i] = cubDT[i + j*p_cubNq];
#endif
    }
    
    @barrier("local");

    sliceThreads{
      
      dfloat tmpU[p_cubNq], tmpV[p_cubNq], tmpW[p_cubNq];
      
      int i = a, j = b;
      
      if(j<p_Nq && i<p_Nq){
#pragma unroll p_cubNq
	for(int k=0;k<p_cubNq;++k){
	  tmpU[k] = 0; tmpV[k] = 0; tmpW[k] = 0;
	}

	int cnt = 0;
#pragma unroll p_Nq
	for(int k=0;k<p_Nq;++k){

	  const dlong id = p_dim*p_Np*e + k*p_Nq*p_Nq + j*p_Nq + i;
	  dfloat Uk = U[id+0*p_Np];
	  dfloat Vk = U[id+1*p_Np];
	  dfloat Wk = U[id+2*p_Np];
	  
#pragma unroll p_cubNq
	  for(int n=0;n<p_cubNq;++n){

#ifdef FLATTEN
	    dfloat Ink = s_cubInterpFlat[cnt]; ++cnt;
#else
	    dfloat Ink = s_cubInterp[k][n];
#endif
	    tmpU[n] += Ink*Uk;
	    tmpV[n] += Ink*Vk;
	    tmpW[n] += Ink*Wk;
	  }
	}

#pragma unroll p_cubNq
	for(int k=0;k<p_cubNq;++k){
	  s_tmpU[0][k][j][i] = tmpU[k];
	  s_tmpU[1][k][j][i] = tmpV[k];
	  s_tmpU[2][k][j][i] = tmpW[k];
	}
      }
    }

    @barrier("local");

    sliceThreads{

      dfloat tmpU[p_cubNq], tmpV[p_cubNq], tmpW[p_cubNq];
      
      int i = a, k = b;
      
      if(i<p_Nq){

#pragma unroll p_cubNq
	for(int j=0;j<p_cubNq;++j){
	  tmpU[j] = 0; tmpV[j] = 0; tmpW[j] = 0;
	}

	int cnt = 0;
#pragma unroll p_Nq
	for(int j=0;j<p_Nq;++j){
	  dfloat Uj = s_tmpU[0][k][j][i];
	  dfloat Vj = s_tmpU[1][k][j][i];
	  dfloat Wj = s_tmpU[2][k][j][i];
	  
#pragma unroll p_cubNq
	  for(int n=0;n<p_cubNq;++n){

#ifdef FLATTEN
	    dfloat Inj = s_cubInterpFlat[cnt]; ++cnt;
#else
	    dfloat Inj = s_cubInterp[j][n];
#endif
	    tmpU[n] += Inj*Uj;
	    tmpV[n] += Inj*Vj;
	    tmpW[n] += Inj*Wj;
	  }
	}
	
#pragma unroll p_cubNq
	for(int j=0;j<p_cubNq;++j){
	  s_tmpU[0][k][j][i] = tmpU[j];
	  s_tmpU[1][k][j][i] = tmpV[j];
	  s_tmpU[2][k][j][i] = tmpW[j];
	}
      }
    }
      
    @barrier("local");

    sliceThreads{
      
      dfloat tmpU[p_cubNq], tmpV[p_cubNq], tmpW[p_cubNq];
      
      int j = a, k = b;

#pragma unroll p_cubNq
      for(int i=0;i<p_cubNq;++i){
	tmpU[i] = 0; tmpV[i] = 0; tmpW[i] = 0; 
      }

      int cnt =0;
#pragma unroll p_Nq      
      for(int i=0;i<p_Nq;++i){
	dfloat Ui = s_tmpU[0][k][j][i];
	dfloat Vi = s_tmpU[1][k][j][i];
	dfloat Wi = s_tmpU[2][k][j][i];
	  
#pragma unroll p_cubNq
	for(int n=0;n<p_cubNq;++n){

#ifdef FLATTEN
	  dfloat Ini = s_cubInterpFlat[cnt]; ++cnt;
#else
	  dfloat Ini = s_cubInterp[i][n];
#endif
	  tmpU[n] += Ini*Ui;
	  tmpV[n] += Ini*Vi;
	  tmpW[n] += Ini*Wi;
	}
      }

#pragma unroll p_cubNq
      for(int i=0;i<p_cubNq;++i){
	s_tmpU[0][k][j][i] = tmpU[i];
	s_tmpU[1][k][j][i] = tmpV[i];
	s_tmpU[2][k][j][i] = tmpW[i];
      }
    }
    
    @exclusive dfloat divr[p_cubNq], divs[p_cubNq], divt[p_cubNq];
      
    // do not unroll ?
    //#pragma unroll p_dim
    for(int fld=0;fld<p_dim;++fld){

      @barrier("local");
      
      sliceThreads{

#pragma unroll p_cubNq
	for(int n=0;n<p_cubNq;++n){
	  divr[n] = 0;
	  divs[n] = 0;
	  divt[n] = 0;
	}
	
#pragma unroll p_cubNq
	for(int i=0;i<p_cubNq;++i){
	  // lean on L1/L2 and also use appropriate layout for this to work
#if 0
	  dlong id = e*p_cubNp*p_dim + i*p_cubNq*p_cubNq + b*p_cubNq + a;
	  dfloat Uei = cUe[id+0*p_cubNp];
	  dfloat Vei = cUe[id+1*p_cubNp];
	  dfloat Wei = cUe[id+2*p_cubNp];
#endif
#if 1
	  //	  dlong id = e*p_cubNp*p_dim + i*p_cubNq*p_cubNq + b*p_cubNq + a;
	  dlong id1 = e*p_cubNp*p_dim + b*p_cubNq*p_cubNq + a*p_cubNq + i;
	  dfloat Uei = __ldg(cUe+id1+0*p_cubNp);
	  dlong id2 = e*p_cubNp*p_dim + b*p_cubNq*p_cubNq + i*p_cubNq + a;
	  dfloat Vei = __ldg(cUe+id2+1*p_cubNp);
	  dlong id3 = e*p_cubNp*p_dim + i*p_cubNq*p_cubNq + b*p_cubNq + a;
	  dfloat Wei = __ldg(cUe+id3+2*p_cubNp);
#endif

	  dfloat UF = Uei*s_tmpU[fld][b][a][i];
	  dfloat UG = Vei*s_tmpU[fld][b][i][a];
	  dfloat UH = Wei*s_tmpU[fld][i][b][a];

	  // this is different 
#pragma unroll p_cubNq
	  for (int n=0;n<p_cubNq;n++) {
	    const dfloat D = s_cubDT[i][n];//s_cubDT[i][n]; FIX THIS ?
	    divr[n] += D*UF; // => [b][a][n]
	    divs[n] += D*UG; // => [b][n][a]
	    divt[n] += D*UH; // => [n][b][a]
	  }
	}
      }
      
      @barrier("local");
      
      sliceThreads{
	for(int n=0;n<p_cubNq;++n){
	  s_tmpU[fld][b][a][n] = divr[n];
	}
      }
      
      @barrier("local");
      
      sliceThreads{
	for(int n=0;n<p_cubNq;++n){
	  s_tmpU[fld][b][n][a] += divs[n];
	}
      }

      @barrier("local");
      
      sliceThreads{
	for(int n=0;n<p_cubNq;++n){
	  s_tmpU[fld][n][b][a] += divt[n];
	}
      }
    }
    
    @barrier("local");

    sliceThreads{

      dfloat tmpU[p_cubNq], tmpV[p_cubNq], tmpW[p_cubNq];
      
      int i = a, j = b;

#pragma unroll p_cubNq
      for(int k=0;k<p_cubNq;++k){
	tmpU[k] = s_tmpU[0][k][j][i];
	tmpV[k] = s_tmpU[1][k][j][i];
	tmpW[k] = s_tmpU[2][k][j][i];
      }
      int cnt = 0;
#pragma unroll p_Nq
      for(int k=0;k<p_Nq;++k){
	dfloat divUk = 0, divVk = 0, divWk = 0;
#pragma unroll p_cubNq
	for(int n=0;n<p_cubNq;++n){
#ifdef FLATTEN
	  dfloat Pkn = s_cubProjectFlat[cnt]; ++cnt;
#else
	  dfloat Pkn = s_cubProject[n][k];
#endif
	  divUk += Pkn*tmpU[n];
	  divVk += Pkn*tmpV[n];
	  divWk += Pkn*tmpW[n];
	}
	s_tmpU[0][k][j][i] = divUk;
	s_tmpU[1][k][j][i] = divVk;
	s_tmpU[2][k][j][i] = divWk;
      }
    }
    
    @barrier("local");
    
    // loop over j    
    sliceThreads{
      
      dfloat tmpU[p_cubNq], tmpV[p_cubNq], tmpW[p_cubNq];
      
      int i = a, k = b;
      if(k<p_Nq){
	
#pragma unroll p_cubNq
	for(int j=0;j<p_cubNq;++j){
	  tmpU[j] = s_tmpU[0][k][j][i];
	  tmpV[j] = s_tmpU[1][k][j][i];
	  tmpW[j] = s_tmpU[2][k][j][i];
	}

	int cnt = 0;
#pragma unroll p_Nq
	for(int j=0;j<p_Nq;++j){
	  dfloat divUj = 0, divVj = 0, divWj = 0;
#pragma unroll p_cubNq
	  for(int n=0;n<p_cubNq;++n){
#ifdef FLATTEN
	    dfloat Pjn = s_cubProjectFlat[cnt]; ++cnt;
#else
	    dfloat Pjn = s_cubProject[n][j];
#endif
	    divUj += Pjn*tmpU[n];
	    divVj += Pjn*tmpV[n];
	    divWj += Pjn*tmpW[n];
	  }
	  s_tmpU[0][k][j][i] = divUj;
	  s_tmpU[1][k][j][i] = divVj;
	  s_tmpU[2][k][j][i] = divWj;
	}
      }
    }

    @barrier("local");
    
    // loop over i
    sliceThreads{

      dfloat tmpU[p_cubNq], tmpV[p_cubNq], tmpW[p_cubNq];
      
      int j = a, k = b;
      if(j<p_Nq && k<p_Nq){
	
#pragma unroll p_cubNq
	for(int i=0;i<p_cubNq;++i){
	  tmpU[i] = s_tmpU[0][k][j][i];
	  tmpV[i] = s_tmpU[1][k][j][i];
	  tmpW[i] = s_tmpU[2][k][j][i];
	}

	int cnt = 0;
#pragma unroll p_Nq	
	for(int i=0;i<p_Nq;++i){
	  dfloat divUi = 0, divVi = 0, divWi = 0;
#pragma unroll p_cubNq
	  for(int n=0;n<p_cubNq;++n){
#ifdef FLATTEN
	    dfloat Pin = s_cubProjectFlat[cnt]; ++cnt;
#else
	    dfloat Pin = s_cubProject[n][i];
#endif
	    divUi += Pin*tmpU[n];
	    divVi += Pin*tmpV[n];
	    divWi += Pin*tmpW[n];
	  }
	  s_tmpU[0][k][j][i] = divUi;
	  s_tmpU[1][k][j][i] = divVi;
	  s_tmpU[2][k][j][i] = divWi;
	}
      }
    } // end fld
    

    @barrier("local");
    
    // output: loop over k
    sliceThreads{
      int i = a, j = b;
      
      if(i<p_Nq & j<p_Nq){
#pragma unroll p_Nq
	for(int k=0;k<p_Nq;++k){
	  const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
	  const dfloat invJW = vgeo[gid + p_IJWID*p_Np];
	  
	  const dlong id = e*p_Np*p_dim + k*p_Nq*p_Nq + j*p_Nq + i;
	  RHS[id+0*p_Np] = invJW*s_tmpU[0][k][j][i];
	  RHS[id+1*p_Np] = invJW*s_tmpU[1][k][j][i];
	  RHS[id+2*p_Np] = invJW*s_tmpU[2][k][j][i];
	}
      }
    }
  }
}





#define quadSurfaceTerms(face)                                          \
  {                                                                     \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if(i<p_Nq && j<p_Nq){                                           \
          const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;  \
          const dlong idM = vmapM[id];                                  \
          const dlong idP = vmapP[id];                                  \
          const dlong eM = e;                                           \
          const dlong eP = idP/p_Np;                                    \
          const int vidM = idM%p_Np;                                    \
          const int vidP = idP%p_Np;                                    \
                                                                        \
          const dlong qbaseM = eM*p_Np*p_NVfields + vidM;               \
          const dlong qbaseP = eP*p_Np*p_NVfields + vidP;               \
                                                                        \
          s_UM[j][i] = Ue[qbaseM+0*p_Np];                               \
          s_VM[j][i] = Ue[qbaseM+1*p_Np];                               \
          s_WM[j][i] = Ue[qbaseM+2*p_Np];                               \
          s_UP[j][i] = Ue[qbaseP+0*p_Np];                               \
          s_VP[j][i] = Ue[qbaseP+1*p_Np];                               \
          s_WP[j][i] = Ue[qbaseP+2*p_Np];                               \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq) {                                                   \
          r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;                           \
          r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;                           \
          for (int n=0;n<p_Nq;n++) {                                    \
            const dfloat Ini = s_cubInterp[n][i];                      \
            r_UMn  += Ini*s_UM[j][n];                                   \
            r_VMn  += Ini*s_VM[j][n];                                   \
            r_WMn  += Ini*s_WM[j][n];                                   \
            r_UPn  += Ini*s_UP[j][n];                                   \
            r_VPn  += Ini*s_VP[j][n];                                   \
            r_WPn  += Ini*s_WP[j][n];                                   \
          }                                                             \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq) {                                                   \
          s_UM[j][i] = r_UMn;                                           \
          s_VM[j][i] = r_VMn;                                           \
          s_WM[j][i] = r_WMn;                                           \
          s_UP[j][i] = r_UPn;                                           \
          s_VP[j][i] = r_VPn;                                           \
          s_WP[j][i] = r_WPn;                                           \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;                             \
        r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;                             \
        for (int n=0;n<p_Nq;n++) {                                      \
          const dfloat Inj = s_cubInterp[n][j];                        \
          r_UMn += Inj*s_UM[n][i];                                      \
          r_VMn += Inj*s_VM[n][i];                                      \
          r_WMn += Inj*s_WM[n][i];                                      \
          r_UPn += Inj*s_UP[n][i];                                      \
          r_VPn += Inj*s_VP[n][i];                                      \
          r_WPn += Inj*s_WP[n][i];                                      \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if(i<p_Nq && j<p_Nq){                                           \
          const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;  \
          const dlong idM = vmapM[id];                                  \
          const dlong idP = vmapP[id];                                  \
          const dlong eM = e;                                           \
          const dlong eP = idP/p_Np;                                    \
          const int vidM = idM%p_Np;                                    \
          const int vidP = idP%p_Np;                                    \
                                                                        \
          const dlong qbaseM = eM*p_Np*p_NVfields + vidM;               \
          const dlong qbaseP = eP*p_Np*p_NVfields + vidP;               \
                                                                        \
          s_UM[j][i] = U[qbaseM+0*p_Np];                                \
          s_VM[j][i] = U[qbaseM+1*p_Np];                                \
          s_WM[j][i] = U[qbaseM+2*p_Np];                                \
          s_UP[j][i] = U[qbaseP+0*p_Np];                                \
          s_VP[j][i] = U[qbaseP+1*p_Np];                                \
          s_WP[j][i] = U[qbaseP+2*p_Np];                                \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq) {                                                   \
          r_UdMn = 0.; r_VdMn = 0.; r_WdMn = 0.;                        \
          r_UdPn = 0.; r_VdPn = 0.; r_WdPn = 0.;                        \
          for (int n=0;n<p_Nq;n++) {                                    \
            const dfloat Ini = s_cubInterp[n][i];                      \
            r_UdMn  += Ini*s_UM[j][n];                                  \
            r_VdMn  += Ini*s_VM[j][n];                                  \
            r_WdMn  += Ini*s_WM[j][n];                                  \
            r_UdPn  += Ini*s_UP[j][n];                                  \
            r_VdPn  += Ini*s_VP[j][n];                                  \
            r_WdPn  += Ini*s_WP[j][n];                                  \
          }                                                             \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq) {                                                   \
          s_UM[j][i] = r_UdMn;                                          \
          s_VM[j][i] = r_VdMn;                                          \
          s_WM[j][i] = r_WdMn;                                          \
          s_UP[j][i] = r_UdPn;                                          \
          s_VP[j][i] = r_VdPn;                                          \
          s_WP[j][i] = r_WdPn;                                          \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        r_UdMn = 0.; r_VdMn = 0.; r_WdMn = 0.;                          \
        r_UdPn = 0.; r_VdPn = 0.; r_WdPn = 0.;                          \
        for (int n=0;n<p_Nq;n++) {                                      \
          const dfloat Inj = s_cubInterp[n][j];                        \
          r_UdMn += Inj*s_UM[n][i];                                     \
          r_VdMn += Inj*s_VM[n][i];                                     \
          r_WdMn += Inj*s_WM[n][i];                                     \
          r_UdPn += Inj*s_UP[n][i];                                     \
          r_VdPn += Inj*s_VP[n][i];                                     \
          r_WdPn += Inj*s_WP[n][i];                                     \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        const dlong sk = e*p_cubNfp*p_Nfaces + face*p_cubNfp + j*p_cubNq + i; \
        const dfloat nx = cubsgeo[sk*p_Nsgeo+p_NXID];                   \
        const dfloat ny = cubsgeo[sk*p_Nsgeo+p_NYID];                   \
        const dfloat nz = cubsgeo[sk*p_Nsgeo+p_NZID];                   \
        const dfloat WsJ = cubsgeo[sk*p_Nsgeo+p_WSJID];                 \
        const dfloat uM = r_UMn, vM = r_VMn, wM = r_WMn;                \
        const dfloat uP = r_UPn, vP = r_VPn, wP = r_WPn;                \
        const dfloat udM = r_UdMn, vdM = r_VdMn, wdM = r_WdMn;          \
        dfloat udP = r_UdPn, vdP = r_VdPn, wdP = r_WdPn;                \
                                                                        \
        const int bc = EToB[face+p_Nfaces*e];                           \
        if(bc>0) {                                                      \
          insVelocityDirichletConditions3D(bc, nu, time, intx[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i], \
                                           inty[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i], \
                                           intz[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i], nx, ny, nz, udM, vdM, wdM, &udP, &vdP, &wdP); \
        }                                                               \
                                                                        \
        const dfloat unM   = fabs(nx*uM + ny*vM + nz*wM);               \
        const dfloat unP   = fabs(nx*uP + ny*vP + nz*wP);               \
        const dfloat unMax = (unM > unP) ? unM : unP;                   \
                                                                        \
        s_fluxNU[j][i] = WsJ*(.5f*(nx*(uP*udP + uM*udM)                 \
                                   + ny*(vP*udP + vM*udM)               \
                                   + nz*(wP*udP + wM*udM)  + unMax*(udM-udP) )); \
        s_fluxNV[j][i] = WsJ*(.5f*(nx*(uP*vdP + uM*vdM)                 \
                                   + ny*(vP*vdP + vM*vdM)               \
                                   + nz*(wP*vdP + wM*vdM)  + unMax*(vdM-vdP) )); \
        s_fluxNW[j][i] = WsJ*(.5f*(nx*(uP*wdP + uM*wdM)                 \
                                   + ny*(vP*wdP + vM*wdM)               \
                                   + nz*(wP*wdP + wM*wdM)  + unMax*(wdM-wdP) )); \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq) {                                                   \
          r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;                           \
          for (int n=0;n<p_cubNq;n++) {                                 \
            const dfloat Pnj = s_cubProject[n][j];                     \
            r_NUn  += Pnj*s_fluxNU[n][i];                               \
            r_NVn  += Pnj*s_fluxNV[n][i];                               \
            r_NWn  += Pnj*s_fluxNW[n][i];                               \
          }                                                             \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq) {                                                   \
          s_fluxNU[j][i] = r_NUn;                                       \
          s_fluxNV[j][i] = r_NVn;                                       \
          s_fluxNW[j][i] = r_NWn;                                       \
        }                                                               \
      }                                                                 \
    }                                                                   \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq && i<p_Nq) {                                         \
          r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;                           \
          for(int n=0;n<p_cubNq;++n){                                   \
            const dfloat Pni = s_cubProject[n][i];                     \
            r_NUn += Pni*s_fluxNU[j][n];                                \
            r_NVn += Pni*s_fluxNV[j][n];                                \
            r_NWn += Pni*s_fluxNW[j][n];                                \
          }                                                             \
        }                                                               \
      }                                                                 \
    }                                                                   \
                                                                        \
    @barrier("local");                                                  \
                                                                        \
    for(int j=0;j<p_cubNq;++j;@inner(1)){                               \
      for(int i=0;i<p_cubNq;++i;@inner(0)){                             \
        if (j<p_Nq && i<p_Nq) {                                         \
          s_fluxNU[j][i] = r_NUn;                                       \
          s_fluxNV[j][i] = r_NVn;                                       \
          s_fluxNW[j][i] = r_NWn;                                       \
        }                                                               \
      }                                                                 \
    }                                                                   \
  }


@kernel void insSubcycleAdvectionCubatureSurfaceHex3D(const dlong Nelements,
                                            @restrict const  dfloat *  vgeo,
                                            @restrict const  dfloat *  cubsgeo,
                                            @restrict const  dfloat *  cubInterp,
                                            @restrict const  dfloat *  cubProject,
                                            @restrict const  dlong  *  vmapM,
                                            @restrict const  dlong  *  vmapP,
                                            @restrict const  int    *  EToB,
                                            const dfloat time,
                                            @restrict const  dfloat *  intx,
                                            @restrict const  dfloat *  inty,
                                            @restrict const  dfloat *  intz,
                                            const dfloat nu,
                                            @restrict const  dfloat *  Ue,
                                            @restrict const  dfloat *  U,
                                                  @restrict  dfloat *  RHS){

  // for all elements
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    // @shared storage for flux terms
    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    @shared dfloat s_UM[p_cubNq][p_cubNq];
    @shared dfloat s_VM[p_cubNq][p_cubNq];
    @shared dfloat s_WM[p_cubNq][p_cubNq];
    @shared dfloat s_UP[p_cubNq][p_cubNq];
    @shared dfloat s_VP[p_cubNq][p_cubNq];
    @shared dfloat s_WP[p_cubNq][p_cubNq];

    // reuse @shared memory buffers
    #define s_fluxNU s_UM
    #define s_fluxNV s_VM
    #define s_fluxNW s_WM

    @exclusive dfloat r_UMn, r_VMn, r_WMn;
    @exclusive dfloat r_UPn, r_VPn, r_WPn;
    @exclusive dfloat r_UdMn, r_VdMn, r_WdMn;
    @exclusive dfloat r_UdPn, r_VdPn, r_WdPn;

    #define r_NUn r_UMn
    #define r_NVn r_VMn
    #define r_NWn r_WMn

    @shared dfloat s_cubInterp[p_Nq][p_cubNq];
    @shared dfloat s_cubProject[p_cubNq][p_Nq];

    // for all face nodes of all elements
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        //zero out resulting surface contributions
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }

        //fetch reference operators
        if (j<p_Nq) {
          s_cubInterp[j][i] = cubInterp[i+j*p_cubNq];
        }
        if (i<p_Nq) {
          s_cubProject[j][i] = cubProject[i+j*p_Nq];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(0) //face 0

    @barrier("local");

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i<p_Nq) {
          r_NU[0] += s_fluxNU[j][i];
          r_NV[0] += s_fluxNV[j][i];
          r_NW[0] += s_fluxNW[j][i];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(5) //face 5

    @barrier("local");

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i<p_Nq) {
          r_NU[p_Nq-1] += s_fluxNU[j][i];
          r_NV[p_Nq-1] += s_fluxNV[j][i];
          r_NW[p_Nq-1] += s_fluxNW[j][i];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(1) //face 1

    @barrier("local");

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j==0 && i<p_Nq) {//face 1
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][i];
            r_NV[n] += s_fluxNV[n][i];
            r_NW[n] += s_fluxNW[n][i];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(3) //face 3

    @barrier("local");

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j==p_Nq-1 && i<p_Nq) {//face 3
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][i];
            r_NV[n] += s_fluxNV[n][i];
            r_NW[n] += s_fluxNW[n][i];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(2) //face 2

    @barrier("local");

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i==p_Nq-1) {//face 2
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][j];
            r_NV[n] += s_fluxNV[n][j];
            r_NW[n] += s_fluxNW[n][j];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(4) //face 4

    @barrier("local");

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i==0) {//face 4
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][j];
            r_NV[n] += s_fluxNV[n][j];
            r_NW[n] += s_fluxNW[n][j];
          }
        }
      }
    }

    @barrier("local");

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if(i<p_Nq && j<p_Nq){
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np*p_NVfields + k*p_Nq*p_Nq + j*p_Nq + i;

            RHS[id+0*p_Np] -= invJW*r_NU[k];
            RHS[id+1*p_Np] -= invJW*r_NV[k];
            RHS[id+2*p_Np] -= invJW*r_NW[k];
          }
        }
      }
    }
  }
}
#undef quadSurfaceTerms


@kernel void insSubcycleAdvectionCubatureInterpolationHex3D(const dlong Nelements,
							    @restrict const  dfloat *  cubvgeo,
							    @restrict const  dfloat *  cubInterp,
							    @restrict const  dfloat *  Ue,
							    @restrict  dfloat *  cUe){

  //----------------------------@kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_cubInterp[p_Nq][p_cubNq];

    @shared dfloat s_Ue[p_cubNq][p_cubNq][p_cubNq];
    @shared dfloat s_Ve[p_cubNq][p_cubNq][p_cubNq];
    @shared dfloat s_We[p_cubNq][p_cubNq][p_cubNq];
		    
    cubeThreads{
      const int id = i+j*p_cubNq + k*p_cubNq*p_cubNq;
      if (id<p_Nq*p_cubNq) {
	s_cubInterp[0][id] = cubInterp[id];
      }

      if(k<p_Nq && j<p_Nq && i<p_Nq){
	const dlong id = e*p_Np*p_NVfields + k*p_Nq*p_Nq + j*p_Nq + i;
	s_Ue[k][j][i] = Ue[id+0*p_Np];
	s_Ve[k][j][i] = Ue[id+1*p_Np];
	s_We[k][j][i] = Ue[id+2*p_Np];
      }
    }

    @barrier("local");
    
    @exclusive dfloat r_IUe, r_IVe, r_IWe;
    
    cubeThreads{
      if(i<p_Nq && j<p_Nq){
	r_IUe = 0; r_IVe = 0; r_IWe = 0;

#pragma unroll p_Nq
	for(int n=0;n<p_Nq;++n){
	  dfloat Ikn = s_cubInterp[n][k];
		
	  r_IUe += Ikn*s_Ue[n][j][i];
	  r_IVe += Ikn*s_Ve[n][j][i];
	  r_IWe += Ikn*s_We[n][j][i];
	}
      }
    }

    @barrier("local");
    
    cubeThreads{
      if(i<p_Nq && j<p_Nq){
	s_Ue[k][j][i] = r_IUe;
	s_Ve[k][j][i] = r_IVe;
	s_We[k][j][i] = r_IWe;
      }
    }

    @barrier("local");

    cubeThreads{
      if(i<p_Nq){
	r_IUe = 0; r_IVe = 0; r_IWe = 0;
#pragma unroll p_Nq
	for(int n=0;n<p_Nq;++n){
	  dfloat Ijn = s_cubInterp[n][j];

	  r_IUe += Ijn*s_Ue[k][n][i];
	  r_IVe += Ijn*s_Ve[k][n][i];
	  r_IWe += Ijn*s_We[k][n][i];
	}
      }
    }

    @barrier("local");
    
    cubeThreads{
      if(i<p_Nq){
	s_Ue[k][j][i] = r_IUe;
	s_Ve[k][j][i] = r_IVe;
	s_We[k][j][i] = r_IWe;
      }
    }
    
    
    cubeThreads{

      r_IUe = 0; r_IVe = 0; r_IWe = 0;
      
#pragma unroll p_Nq
      for(int n=0;n<p_Nq;++n){
	dfloat Iin = s_cubInterp[n][i];

	r_IUe += Iin*s_Ue[k][j][n];
	r_IVe += Iin*s_Ve[k][j][n];
	r_IWe += Iin*s_We[k][j][n];
      }

      const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
      const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
      const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
      const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
      const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
      const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
      const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
      const dfloat dtdx = cubvgeo[gid + p_TXID*p_cubNp];
      const dfloat dtdy = cubvgeo[gid + p_TYID*p_cubNp];
      const dfloat dtdz = cubvgeo[gid + p_TZID*p_cubNp];
      const dfloat JW   = cubvgeo[gid + p_JWID*p_cubNp];
      
      const dfloat cUn = JW*(drdx*r_IUe+drdy*r_IVe+drdz*r_IWe);
      const dfloat cVn = JW*(dsdx*r_IUe+dsdy*r_IVe+dsdz*r_IWe);
      const dfloat cWn = JW*(dtdx*r_IUe+dtdy*r_IVe+dtdz*r_IWe);

      const dlong id = e*p_cubNp*p_NVfields + k*p_cubNq*p_cubNq + j*p_cubNq + i;
      cUe[id+0*p_cubNp] = cUn;
      cUe[id+1*p_cubNp] = cVn;
      cUe[id+2*p_cubNp] = cWn;
    }
  }
}


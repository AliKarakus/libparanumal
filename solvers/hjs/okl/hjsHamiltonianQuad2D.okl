// compute NU  = -div(uxu) in collocation way
@kernel void hjsHamiltonianQuad2D(const dlong Nelements,
                                 @restrict const  dfloat *  vgeo,
                                 const dfloat time, 
                                 @restrict const  dfloat *  x,
                                 @restrict const  dfloat *  y,
                                 @restrict const  dfloat *  z,
                                 @restrict const  dfloat *  gradq,
                                 @restrict dfloat *  rhs){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements
   // Hold Flux Vector on Shared
    @shared dfloat s_alpha[p_NblockV][p_Np];
    @shared dfloat s_beta[p_NblockV][p_Np];   
    @exclusive dfloat p1, p2, q1, q2, ham;
    @exclusive dfloat r_alpha[p_NblockV];  
    @exclusive dfloat r_beta[p_NblockV]; 

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){ 
           const dlong id = e*p_Np*(2*p_dim) + n;
           p1 =  gradq[id + 0*p_Np];
           p2 =  gradq[id + 1*p_Np];
           q1 =  gradq[id + 2*p_Np];
           q2 =  gradq[id + 3*p_Np];

           dfloat dhdp = 0.f, dhdq = 0.f; 
           ham   =  0.f;
           hjsComputeHamiltonian2D(time, x[e*p_Np + n], y[e*p_Np + n], p1, p2, q1, q2, &ham, &dhdp,&dhdq); 
           s_alpha[es][n] = dhdp;  
           s_beta[es][n]  = dhdq;  
           if(n==0){
            r_alpha[es]=0.f; 
            r_beta[es] =0.f; 
           }
        } 
      }
    }

    // Very ugly, revisit later!!!!!!!!!!!
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        const dlong e = eo+es;
        if(e<Nelements){
          if(n==0){
            r_alpha[es] = s_alpha[es][0]; 
            r_beta[es]  = s_beta[es][0]; 
            for(int i=1; i<p_Np; i++){
             r_alpha[es]=  r_alpha[es]>s_alpha[es][i] ? r_alpha[es]:s_alpha[es][i]; 
             r_beta[es] =  r_beta[es]>s_beta[es][i] ? r_beta[es]:s_beta[es][i];  
            }
          }          
        }
      }
    }

@barrier("local");

for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        const dlong e = eo+es;
        if(e<Nelements){
         const dlong id = e*p_Np+ n;
         rhs[id] = -( ham - 0.5*r_alpha[es]*(p1-p2)-0.5*r_beta[es]*(q1-q2)); 
        }
      }
    }

  }
}


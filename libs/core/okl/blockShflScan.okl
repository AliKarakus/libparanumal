/* The MIT License (MIT)
 *
 * Copyright (c) 2014-2018 David Medina and Tim Warburton
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 */


#define MASK 0xffffffff

#define p_SIMD 32
#define p_NWARPS (SCAN_BLOCK_SIZE/p_SIMD)

@kernel void blockShflScan(dlong N, entry_t *o_a, scan_t *o_scana, scan_t *o_offsets){

  for(dlong b=0;b<(N+SCAN_BLOCK_SIZE-1)/SCAN_BLOCK_SIZE;++b;@outer(0)){

    @shared scan_t s_offsets[p_NWARPS];
    @exclusive scan_t x;
    @exclusive int l, w;
    @exclusive dlong n;
    
    for(int t=0;t<SCAN_BLOCK_SIZE;++t;@inner(0)){
  
      // find lane
      l = t%p_SIMD;
      
      // find warp
      w = t >> 5; // divides by 32
      
      // construct map from thread and thread-block indices into linear array index
      n = t + b*SCAN_BLOCK_SIZE;

      dlong n1 = (n>0) ? n-1:0;
      
      // assume map to integer depends on entry n and n-1
      x = entryMap(o_a[n],o_a[n1]); 
      
      // warp based scan using shfl op
      scan_t y;
      y = __shfl_up_sync(MASK, x,  1, p_SIMD); x += (l>= 1) ? y : 0;
      y = __shfl_up_sync(MASK, x,  2, p_SIMD); x += (l>= 2) ? y : 0;
      y = __shfl_up_sync(MASK, x,  4, p_SIMD); x += (l>= 4) ? y : 0;
      y = __shfl_up_sync(MASK, x,  8, p_SIMD); x += (l>= 8) ? y : 0;
      y = __shfl_up_sync(MASK, x, 16, p_SIMD); x += (l>=16) ? y : 0;

      // collect warp offsets
      if(l==31) s_offsets[w] = x;
    }

    @barrier("local"); // ensure all warps have contributed offset
    
    for(int t=0;t<SCAN_BLOCK_SIZE;++t;@inner(0)){
      
      // nominate warp 0 to scan offsets
      if(w==0){
	scan_t offx = s_offsets[l];
	scan_t y;
	y = __shfl_up_sync(MASK, offx,  1, p_SIMD); offx += (l>= 1) ? y : 0;
	y = __shfl_up_sync(MASK, offx,  2, p_SIMD); offx += (l>= 2) ? y : 0;
	y = __shfl_up_sync(MASK, offx,  4, p_SIMD); offx += (l>= 4) ? y : 0;
	y = __shfl_up_sync(MASK, offx,  8, p_SIMD); offx += (l>= 8) ? y : 0;
	y = __shfl_up_sync(MASK, offx, 16, p_SIMD); offx += (l>=16) ? y : 0;

	s_offsets[l] = offx;
      }
    }

    @barrier("local"); // ensure all warps have contributed offset
    
    for(int t=0;t<SCAN_BLOCK_SIZE;++t;@inner(0)){
      
      // shift by warp offset
      x += (w!=0) ? s_offsets[w-1]:0;
      
      if(n<N)
	o_scana[n] = x;
      
      if(t==SCAN_BLOCK_SIZE-1)
	o_offsets[b] = x;
    }
  }
}




@kernel void finalizeScan(dlong N, scan_t *o_offsets, scan_t *o_scana){

  for(dlong b=0;b<(N+SCAN_BLOCK_SIZE-1)/SCAN_BLOCK_SIZE;++b;@outer(0)){

    for(int t=0;t<SCAN_BLOCK_SIZE;++t;@inner(0)){
      // construct map from thread and thread-block indices into linear array index
      dlong n = t + b*SCAN_BLOCK_SIZE;
      
      if(b>0)
	o_scana[n] += o_offsets[b-1];
    }
  }
}


@kernel void findStarts(dlong N, dlong Nstarts, scan_t *o_scan, scan_t *o_starts){

  for(int n=0;n<N;++n;@tile(256, @outer,@inner)){

    if(n==0)
      o_starts[n] = 0;
    else{
      dlong id = o_scan[n];
      if(id!=o_scan[n-1]) // rely on l1
	o_starts[id] = n;
      if(n==N-1)
	o_starts[Nstarts] = N;
    }
  }


}

@kernel void trashCompactor_orig(dlong N, dlong Nstarts, scan_t *o_starts, entry_t *o_list, entry_t *o_compactedList){

  for(dlong s=0;s<Nstarts;++s;@outer(0)){

    for(int t=0;t<p_SIMD;++t;@inner(0)){

      dlong id0 = o_starts[s];
      dlong id1 = o_starts[s+1];
      
      dlong n = id0 + t;

      // assume 1 val (sorry)
      dfloat val = 0;
      while(n<id1){
	val += o_list[n].val; // nasty striding
	n+=p_SIMD;
      }

      dfloat y;
      y = __shfl_down_sync(MASK, val,  16, p_SIMD); val += (t<16) ? y : 0;
      y = __shfl_down_sync(MASK, val,   8, p_SIMD); val += (t< 8) ? y : 0;
      y = __shfl_down_sync(MASK, val,   4, p_SIMD); val += (t< 4) ? y : 0;
      y = __shfl_down_sync(MASK, val,   2, p_SIMD); val += (t< 2) ? y : 0;
      y = __shfl_down_sync(MASK, val,   1, p_SIMD); val += (t< 1) ? y : 0;

      if(t==0){
	entry_t acc = o_list[id0]; // should be in l1 (recovers nasty striding  a bit)
	acc.val = val;
	o_compactedList[s] = acc;
      }
    }
  }

}



@kernel void trashCompactor(dlong N, dlong Nstarts, scan_t *o_starts, entry_t *o_list, entry_t *o_compactedList){

  for(dlong s=0;s<Nstarts;++s;@tile(1024,@outer,@inner)){

    dlong id0 = o_starts[s];
    dlong id1 = o_starts[s+1];

    entry_t acc = o_list[id0]; // should be in l1 (recovers nasty striding  a bit)
    for(dlong n=id0+1;n<id1;++n){
      acc.val += o_list[n].val; // nasty striding
    }

    o_compactedList[s] = acc;
  }
  
}
